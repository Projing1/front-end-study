<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>模块化编程 | 前端学习笔记</title>
    <meta name="description" content="李靖个人前端学习中的一些小心得">
    <meta name="theme-color" content="#3eaf7c">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
    
    <link rel="preload" href="/front-end-study/assets/css/0.styles.32c38af2.css" as="style"><link rel="preload" href="/front-end-study/assets/js/app.0bfce8fd.js" as="script"><link rel="preload" href="/front-end-study/assets/js/2.8d937a8c.js" as="script"><link rel="preload" href="/front-end-study/assets/js/7.996d1dce.js" as="script"><link rel="prefetch" href="/front-end-study/assets/js/10.f52eda7c.js"><link rel="prefetch" href="/front-end-study/assets/js/11.2a207987.js"><link rel="prefetch" href="/front-end-study/assets/js/12.01aa28b7.js"><link rel="prefetch" href="/front-end-study/assets/js/13.4527883c.js"><link rel="prefetch" href="/front-end-study/assets/js/14.c3b7450d.js"><link rel="prefetch" href="/front-end-study/assets/js/15.3aa62ae0.js"><link rel="prefetch" href="/front-end-study/assets/js/16.b9fc4fd3.js"><link rel="prefetch" href="/front-end-study/assets/js/17.54f21fd6.js"><link rel="prefetch" href="/front-end-study/assets/js/18.3eb8d134.js"><link rel="prefetch" href="/front-end-study/assets/js/19.f7a3a423.js"><link rel="prefetch" href="/front-end-study/assets/js/20.79486553.js"><link rel="prefetch" href="/front-end-study/assets/js/21.f3af36a1.js"><link rel="prefetch" href="/front-end-study/assets/js/22.6fba54b1.js"><link rel="prefetch" href="/front-end-study/assets/js/23.9ab5c5d0.js"><link rel="prefetch" href="/front-end-study/assets/js/24.4b066b56.js"><link rel="prefetch" href="/front-end-study/assets/js/25.afa98a0a.js"><link rel="prefetch" href="/front-end-study/assets/js/26.7f00fd65.js"><link rel="prefetch" href="/front-end-study/assets/js/27.87c9010a.js"><link rel="prefetch" href="/front-end-study/assets/js/3.6d86d8d5.js"><link rel="prefetch" href="/front-end-study/assets/js/4.b1577da0.js"><link rel="prefetch" href="/front-end-study/assets/js/5.bdaf13af.js"><link rel="prefetch" href="/front-end-study/assets/js/6.0bcb38c6.js"><link rel="prefetch" href="/front-end-study/assets/js/8.f2b34375.js"><link rel="prefetch" href="/front-end-study/assets/js/9.0a94c988.js">
    <link rel="stylesheet" href="/front-end-study/assets/css/0.styles.32c38af2.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/front-end-study/" class="home-link router-link-active"><!----> <span class="site-name">前端学习笔记</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/front-end-study/guide/" class="nav-link router-link-active">高级前端开发课程</a></div><div class="nav-item"><a href="/front-end-study/config/" class="nav-link">实际项目中的错误汇总</a></div><div class="nav-item"><a href="https://www.vuepress.cn" target="_blank" rel="noopener noreferrer" class="nav-link external">
  VuePress
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/front-end-study/guide/" class="nav-link router-link-active">高级前端开发课程</a></div><div class="nav-item"><a href="/front-end-study/config/" class="nav-link">实际项目中的错误汇总</a></div><div class="nav-item"><a href="https://www.vuepress.cn" target="_blank" rel="noopener noreferrer" class="nav-link external">
  VuePress
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>javascript进阶</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/front-end-study/guide/" class="sidebar-link">Jquery</a></li><li><a href="/front-end-study/guide/underscore.html" class="sidebar-link">underscore</a></li><li><a href="/front-end-study/guide/module.html" class="active sidebar-link">module</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/front-end-study/guide/module.html#模块系统概述" class="sidebar-link">模块系统概述</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/front-end-study/guide/module.html#模块化定义-优势" class="sidebar-link">模块化定义/优势</a></li><li class="sidebar-sub-header"><a href="/front-end-study/guide/module.html#commonjs" class="sidebar-link">commonJS</a></li><li class="sidebar-sub-header"><a href="/front-end-study/guide/module.html#amd（requirejs）" class="sidebar-link">AMD（requirejs）</a></li><li class="sidebar-sub-header"><a href="/front-end-study/guide/module.html#cmd（seajs）" class="sidebar-link">CMD（seajs）</a></li><li class="sidebar-sub-header"><a href="/front-end-study/guide/module.html#es6模块化" class="sidebar-link">ES6模块化</a></li></ul></li><li class="sidebar-sub-header"><a href="/front-end-study/guide/module.html#加载器结构设计导论" class="sidebar-link">加载器结构设计导论</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/front-end-study/guide/module.html#模块部分" class="sidebar-link">模块部分</a></li><li class="sidebar-sub-header"><a href="/front-end-study/guide/module.html#资源部分" class="sidebar-link">资源部分</a></li></ul></li><li class="sidebar-sub-header"><a href="/front-end-study/guide/module.html#module构造器设计——模块数据初始化" class="sidebar-link">module构造器设计——模块数据初始化</a></li><li class="sidebar-sub-header"><a href="/front-end-study/guide/module.html#deepclone深度克隆-pick" class="sidebar-link">deepclone深度克隆&amp;pick</a></li></ul></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>单页应用专题</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>H5移动端开发</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Node开发导学</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="模块化编程"><a href="#模块化编程" class="header-anchor">#</a> 模块化编程</h1> <h2 id="模块系统概述"><a href="#模块系统概述" class="header-anchor">#</a> 模块系统概述</h2> <h3 id="模块化定义-优势"><a href="#模块化定义-优势" class="header-anchor">#</a> 模块化定义/优势</h3> <p>模块化就是把系统分离成独立功能的方法，这样我们需要什么功能，就加载什么功能。<br>
当一个项目开发得越来越复杂时，会遇到一些问题：1、命名冲突，2、文件依赖。使用模块化开发，可以避免以上问题，并且提高开发效率,并且代码可维护行，可复用性较好。在生产角度，模块化开发室一种生产方式，这种方式生产效率高，维护成本低。</p> <h3 id="commonjs"><a href="#commonjs" class="header-anchor">#</a> commonJS</h3> <p>commonjs规范加载模块是同步的，也就是说，加载完成才执行后面的操作，node.js主要用于服务器编程，模块都是存在本地硬盘中加载比较快，所以node.js采用commonjs规范。<br>
commonJs规范分为三部分：</p> <ul><li>moudule（模块标识）：module变量在每个模块内部，就代表当前模块；</li> <li>require（模块引用）：exports属性书对外的接口，用于导出当前模块的方法或变量；</li> <li>exports（模块定义）require用来加载外部模块，读取并执行js文件，返回该模块的exports对象。</li></ul> <h3 id="amd（requirejs）"><a href="#amd（requirejs）" class="header-anchor">#</a> AMD（requirejs）</h3> <p>AMD规范（requirejs）AMD是异步模块定义，它采用异步方式加载模块，通过define方法定义模块，require方法加载模块，<br> <strong>AMD模块的定义</strong>：如果这个模块还需要依赖其他模块，那么define函数的第一个参数，必须是一个数组，指明该模块的依赖，<br> <strong>AMD的加载</strong>：require（['modules',callback]）;第一个参数是一个数组，里面的成员就是要加载的模块。第二个参数callback，则是加载成功后的回调函数，require（）异步加载math，浏览器不会失去响应，它指定的回调函数，只有前面的模块都加载成功后，才会运行，解决了依赖性的问题。</p> <h3 id="cmd（seajs）"><a href="#cmd（seajs）" class="header-anchor">#</a> CMD（seajs）</h3> <p>CMD即通用模块定义，CMD规范是国内发展出来的，正如AMD有requirejs，CMD有个浏览器的实现Seajs；Seajs要解决的问题和requirejs一样，只不过在模块定义方式和模块加载方式上有所不同。 在CMD规范中，一个模块就是一个文件，代码的书写格式如下：define（function（require，exports，module）{//模块代码}）； require是可以把其他模块导入进来的一个参数exports可以把模块内的一些属性和方法导出，module是一个对象，上面存储了与当前模块相关联的一些属性和方法，
CMD推崇依赖就近，延迟执行，文件是提前加载好，只有在require的时候才会去执行文件。</p> <h3 id="es6模块化"><a href="#es6模块化" class="header-anchor">#</a> ES6模块化</h3> <p>ES6模块化：在ES6之前没有模块化，为了解决问题，提出了commonJS，AMD，CMD；ES6模块化汲取了commonJS和AMD的优点，语法简洁，支持异步加载，未来可以成为浏览器和服务器通用的模块化解决方案。ES6新增了两个关键字：<strong>export和import</strong>。</p> <ul><li>export用于把模块里的内容暴露出来，import用于引入模块提供的功能。</li> <li>import加载模块：</li></ul> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">import</span> <span class="token punctuation">{</span>bar<span class="token punctuation">,</span>foo<span class="token punctuation">,</span>test<span class="token punctuation">,</span>obj<span class="token punctuation">}</span> <span class="token keyword">from</span>  <span class="token string">'./lib'</span><span class="token punctuation">;</span>
<span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><div class="custom-block tip"><p class="custom-block-title">TIP</p> <p>注：可以使用Export default命令，为模块制定默认输出，一个模块只能有一个默认输出，所以export default只能使用一次。</p></div> <p><strong>ES6模块运行机制</strong>：ES6模块是动态引用，如果使用import从一个模块加载变量（即： import foo from ‘foo’），变量不会被缓存，而是成为一个指向被加载模块的引用，等脚本执行时，根据只读引用，到被加载的那个模块中取值。<br> <strong>模块的定义</strong>：</p> <ul><li>约定：所有JavaScript文件都应该用模块的形式来书写，并且一个文件只包含一个模块；</li> <li>使用全局函数define来定义模块<code>define（factory[require,exports，module])</code>；exports用来向外提供模块的API||使用return直接向外提供API。require函数用来访问其他模块提供的API。module参数存储模块的元信息，（id模块的唯一标识deps依赖列表exports对外提供额接口对象。</li> <li>factory函数在调用时，会始终传入三个参数：require。exports和module，这三个参数在左右模块代码里可用。模块加载器会从<code>factory.toString()</code>中解析出当前模块所依赖的模块，它是一个有模块标识组成的数组。</li></ul> <div class="custom-block tip"><p class="custom-block-title">TIP</p> <p>所以：1、在模块代码中，第一个参数必须命名为require，2、不要重命名require函数，或在任何作用域中给require重新赋值，3、require的参数值必须是字符串直接量，不能是表达式。</p></div> <h2 id="加载器结构设计导论"><a href="#加载器结构设计导论" class="header-anchor">#</a> 加载器结构设计导论</h2> <p><img src="/front-end-study/assets/img/daolun.01f106ff.png" alt="加载器结构设计"></p> <h3 id="模块部分"><a href="#模块部分" class="header-anchor">#</a> 模块部分</h3> <p>每个模块创建都先初始化数据，存储在缓存对象中。<br>
数据初始化：加载器中设计了一个名为module的构造函数，每个模块都是次构造函数的实例对象。构造函数中给实例对象扩展了“未来”所需要用到的属性和方法。<br>
模块存储：加载器中设计了一个名为cache缓存对象，每个文件（模块）都会存储在cache对象中。具体存储方式：{“当前模块绝对路径”：new Module()}</p> <div class="custom-block warning"><p class="custom-block-title">WARNING</p> <p>注意：当前模块的绝对路径是通过资源部分，资源定位方法实现的。</p></div> <h3 id="资源部分"><a href="#资源部分" class="header-anchor">#</a> 资源部分</h3> <p>资源定位依赖管理是加载器设计两大核心。<br>
资源定位：加载器中设计了一个resolve（）方法把模块名解析成绝对路径格式，模块名的获取：</p> <ul><li>startUp.use([&quot;a.js&quot;,&quot;b.js&quot;]);<br> <code>startUp.use()</code>加载器启动方法，启动时会去调用传入数组列表中的模块。</li> <li>动态加载script文件：通过加载器resolve（）方法把模块名解析成绝对路径格式。动态创建script ：document.creat(&quot;script&quot;);src指向当前模块绝对路径地址，加载文件同时，模块加载器解析当前模块所依赖的模块以数组的形式存储。<br>
依赖管理：已知当前模块在cache中的形态，{&quot;当前模块绝对路径&quot;：new Module（）} 换算：1、{“当前模块绝对路径”：{uri:&quot;当前模块绝对路径&quot;，deps：[]}} ； deps存储当前模块的依赖列表。依赖列表通过动态加载script文件正则解析获取。</li></ul> <div class="custom-block warning"><p class="custom-block-title">WARNING</p> <p>重点：解析依赖——&gt;获取依赖模块绝对路劲地址——&gt;动态加载——&gt;提取依赖——&gt;解析依赖。递归方式加载所有模块，直至模块全部加载完毕。</p></div> <h2 id="module构造器设计——模块数据初始化"><a href="#module构造器设计——模块数据初始化" class="header-anchor">#</a> module构造器设计——模块数据初始化</h2> <p>依赖加载策略，基于树形结构的加载策略。<br>
模块数据初始化：模块初始化——module构造函数——数据初始化：</p> <ul><li>实例方法：load分析主干（子树）上的依赖项resolve资源定位；</li> <li>实例属性：</li> <li><ul><li>this.uri = uri;当前模块的绝对路径地址;</li></ul></li> <li><ul><li>this.deps =deps || [];当前模块依赖列表;</li></ul></li> <li><ul><li>this.exports = null;当前对外暴露接口对象；</li></ul></li> <li><ul><li>this.status = 0;当前模块状态；</li></ul></li> <li><ul><li>This.waitings = {};有多少个依赖项；</li></ul></li> <li><ul><li>this.remain = 0; 还有多少个未加载的依赖项。<br>
模块的生命周期：status = 1 正在当前模块获取uri ;<br>
status = 2 缓存中存储模块数据信息 ；<br>
status = 3 正在加载当前模块依赖项，<br>
status = 4 朱本执行当前模块；<br>
status = 5 正在执行当前模块；status = 6 执行完毕接口以获取。</li></ul></li></ul> <h2 id="deepclone深度克隆-pick"><a href="#deepclone深度克隆-pick" class="header-anchor">#</a> deepclone深度克隆&amp;pick</h2> <ul><li><code>_.clone(object)</code>:克隆一个对象的副本。<code>_deepClone(object)</code>:深度克隆一个对象。两者的区别在于克隆后的对象与原对象是否全等。</li> <li>深度克隆：重新全部复制一个与要复制的对象一样的对象。但是与原对象不是同一个。</li> <li><code>_.pick(object,keys)</code>返回一个object副本，只过滤出keys(有效的键组成的数组)参数指定的属性值，或者接受一个判断函数，指定挑选哪个key。</li></ul></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/front-end-study/guide/underscore.html" class="prev">underscore</a></span> <span class="next"><a href="/front-end-study/foo/">Vue专题</a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/front-end-study/assets/js/app.0bfce8fd.js" defer></script><script src="/front-end-study/assets/js/2.8d937a8c.js" defer></script><script src="/front-end-study/assets/js/7.996d1dce.js" defer></script>
  </body>
</html>
