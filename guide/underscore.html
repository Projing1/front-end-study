<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>函数式编程——underscore | 前端学习笔记</title>
    <meta name="description" content="前端学习中的一些笔记及总结">
    <meta name="theme-color" content="#3eaf7c">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
    
    <link rel="preload" href="/front-end-study/assets/css/0.styles.32c38af2.css" as="style"><link rel="preload" href="/front-end-study/assets/js/app.8d50f10d.js" as="script"><link rel="preload" href="/front-end-study/assets/js/2.8d937a8c.js" as="script"><link rel="preload" href="/front-end-study/assets/js/20.79486553.js" as="script"><link rel="prefetch" href="/front-end-study/assets/js/10.f52eda7c.js"><link rel="prefetch" href="/front-end-study/assets/js/11.2a207987.js"><link rel="prefetch" href="/front-end-study/assets/js/12.01aa28b7.js"><link rel="prefetch" href="/front-end-study/assets/js/13.4527883c.js"><link rel="prefetch" href="/front-end-study/assets/js/14.c3b7450d.js"><link rel="prefetch" href="/front-end-study/assets/js/15.d4d389ff.js"><link rel="prefetch" href="/front-end-study/assets/js/16.a3638bd2.js"><link rel="prefetch" href="/front-end-study/assets/js/17.54f21fd6.js"><link rel="prefetch" href="/front-end-study/assets/js/18.3eb8d134.js"><link rel="prefetch" href="/front-end-study/assets/js/19.f7a3a423.js"><link rel="prefetch" href="/front-end-study/assets/js/21.978f0a17.js"><link rel="prefetch" href="/front-end-study/assets/js/22.6223d7e6.js"><link rel="prefetch" href="/front-end-study/assets/js/23.08148677.js"><link rel="prefetch" href="/front-end-study/assets/js/24.4b066b56.js"><link rel="prefetch" href="/front-end-study/assets/js/25.afa98a0a.js"><link rel="prefetch" href="/front-end-study/assets/js/26.1dd01e6e.js"><link rel="prefetch" href="/front-end-study/assets/js/27.87c9010a.js"><link rel="prefetch" href="/front-end-study/assets/js/3.6cf61e10.js"><link rel="prefetch" href="/front-end-study/assets/js/4.b1577da0.js"><link rel="prefetch" href="/front-end-study/assets/js/5.bdaf13af.js"><link rel="prefetch" href="/front-end-study/assets/js/6.f4717c6c.js"><link rel="prefetch" href="/front-end-study/assets/js/7.996d1dce.js"><link rel="prefetch" href="/front-end-study/assets/js/8.203521e2.js"><link rel="prefetch" href="/front-end-study/assets/js/9.0a94c988.js">
    <link rel="stylesheet" href="/front-end-study/assets/css/0.styles.32c38af2.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/front-end-study/" class="home-link router-link-active"><!----> <span class="site-name">前端学习笔记</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/front-end-study/guide/" class="nav-link router-link-active">高级前端开发课程</a></div><div class="nav-item"><a href="/front-end-study/config/" class="nav-link">实际项目中的错误汇总</a></div><div class="nav-item"><a href="https://www.vuepress.cn" target="_blank" rel="noopener noreferrer" class="nav-link external">
  VuePress
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/front-end-study/guide/" class="nav-link router-link-active">高级前端开发课程</a></div><div class="nav-item"><a href="/front-end-study/config/" class="nav-link">实际项目中的错误汇总</a></div><div class="nav-item"><a href="https://www.vuepress.cn" target="_blank" rel="noopener noreferrer" class="nav-link external">
  VuePress
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>javascript进阶</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/front-end-study/guide/" class="sidebar-link">Jquery</a></li><li><a href="/front-end-study/guide/underscore.html" class="active sidebar-link">underscore</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/front-end-study/guide/underscore.html#函数式编程基础知识" class="sidebar-link">函数式编程基础知识</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/front-end-study/guide/underscore.html#特征：" class="sidebar-link">特征：</a></li><li class="sidebar-sub-header"><a href="/front-end-study/guide/underscore.html#声明式与命令式：" class="sidebar-link">声明式与命令式：</a></li></ul></li><li class="sidebar-sub-header"><a href="/front-end-study/guide/underscore.html#underscore的整体设计" class="sidebar-link">underscore的整体设计</a></li><li class="sidebar-sub-header"><a href="/front-end-study/guide/underscore.html#条件查询，背后索引器实现" class="sidebar-link">条件查询，背后索引器实现</a></li><li class="sidebar-sub-header"><a href="/front-end-study/guide/underscore.html#乱序数组——洗牌算法" class="sidebar-link">乱序数组——洗牌算法</a></li><li class="sidebar-sub-header"><a href="/front-end-study/guide/underscore.html#数组定位与摊平数组" class="sidebar-link">数组定位与摊平数组</a></li><li class="sidebar-sub-header"><a href="/front-end-study/guide/underscore.html#去重函数-源码拾遗" class="sidebar-link">去重函数&amp;源码拾遗</a></li><li class="sidebar-sub-header"><a href="/front-end-study/guide/underscore.html#patial偏函数-与-memoize缓存" class="sidebar-link">.patial偏函数 与 .memoize缓存</a></li><li class="sidebar-sub-header"><a href="/front-end-study/guide/underscore.html#补充知识——正则课程" class="sidebar-link">补充知识——正则课程</a></li><li class="sidebar-sub-header"><a href="/front-end-study/guide/underscore.html#延迟执行函数、字符转义" class="sidebar-link">延迟执行函数、字符转义</a></li><li class="sidebar-sub-header"><a href="/front-end-study/guide/underscore.html#throttle与debounce-概念解析源码分析" class="sidebar-link">throttle与debounce 概念解析源码分析</a></li><li class="sidebar-sub-header"><a href="/front-end-study/guide/underscore.html#属性操作-createassigner" class="sidebar-link">属性操作&amp;createAssigner</a></li></ul></li><li><a href="/front-end-study/guide/module.html" class="sidebar-link">module</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>单页应用专题</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>H5移动端开发</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Node开发导学</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="函数式编程——underscore"><a href="#函数式编程——underscore" class="header-anchor">#</a> 函数式编程——underscore</h1> <h2 id="函数式编程基础知识"><a href="#函数式编程基础知识" class="header-anchor">#</a> 函数式编程基础知识</h2> <h3 id="特征："><a href="#特征：" class="header-anchor">#</a> 特征：</h3> <ul><li>1、纯函数，对于相同的输入，永远会得到相同的输出，而且没有任何可观察的副作用，也不依赖外部环境的状态。eg：数学公式y=F(X)；在JavaScript中，对于数组的操作，有些是纯的，有些是不纯的。</li> <li>2、函数柯里化：定义：向函数传递一部分参数来调用它，让它返回一个函数去处理剩下的参数。事实上，柯里化是一种“预加载”函数的方法，通过传递较少的参数，得到一个已经记住了这些参数的新函数，某种意义上讲，这是一种对参数的“缓存”，是一种非常高效的编写函数的方法。</li> <li>3、函数组合：为避免写出不优雅的包菜式代码h(g(f(x))),我们需要用到函数组合，我们定义的compose就像双面胶一样，可以把任何两个纯函数结合到一起，<em>（传参形式？第一节课7分10秒）</em></li></ul> <h3 id="声明式与命令式："><a href="#声明式与命令式：" class="header-anchor">#</a> 声明式与命令式：</h3> <ul><li>命令式代码：通过编写一条又一条指令，让计算机执行一些动作，其中一般会涉及许多繁杂的细节。</li> <li>声明式代码：通过写表达式的方式，声明我们想干什么，而不是通过一步一步的指示。声明式代码，是函数式编程的一个明显好处——编写、优化代码时能更专注。</li></ul> <div class="custom-block tip"><p class="custom-block-title">TIP</p> <p>函数对于外部状态的依赖，是造成系统复杂性大大提高的主要原因。代码书写中让函数尽可能的纯净，函数式编程不是万能的，它与oop一样，只是一种编程范式。为降低软件复杂度，oop的方式是靠良好的封装、继承、多态、以及接口定义。函数式编程则是靠纯函数以及他们的组合、柯里化等技术。</p></div> <h2 id="underscore的整体设计"><a href="#underscore的整体设计" class="header-anchor">#</a> underscore的整体设计</h2> <ul><li>作用域报过，也是通过立即执行函数来包裹自己的业务逻辑，避免全局污染，隐私保护。(function(){执行逻辑})();</li> <li>对象：通过一个下划线变量_来标识自身。<em>是一个函数对象，所有的api都会被挂载到这个对象上，如</em>.map ，_.each；</li> <li>对面向对象的支持；<em>(),通过</em>()来包裹一个对象，会创建一个新的underscore对象，就能够调用underscore提供的方法，并在<code>this.warpped</code>中存储传入的数据。类似jQuery的 $()包裹进去。</li> <li>扩展：通过mixin混入；</li> <li>支持链式调用。<code>_.chain()</code>:为underscore对象的方法增加链式调用能力。</li></ul> <h2 id="条件查询，背后索引器实现"><a href="#条件查询，背后索引器实现" class="header-anchor">#</a> 条件查询，背后索引器实现</h2> <p>underscore中通过内置的工厂函数createIndexFinder来创建一个索引查询器。 <code>_.indexOf</code>及 <code>_.lastIndexOf</code>正是由该函数所创建的；<br>
createIndexFinder接收三个参数,用来创建indexOf跟lastIndexOf;</p> <ul><li><code>_.indexOf(array,item , sorted)</code>查询array在coll中第一次出现的位置。<code>_.indexOf</code>方法的创建过程中，被传递了<code>_.findindex</code>作为元素的直值预测函数，以及<code>_.sortedIndex</code>作为当数组有序时获得索引的方式。</li> <li><code>_.lastIndexOf(array,item,sorted)</code>：查询item在array中最后一次出现的位置。</li></ul> <h2 id="乱序数组——洗牌算法"><a href="#乱序数组——洗牌算法" class="header-anchor">#</a> 乱序数组——洗牌算法</h2> <p>算法思路在宏观上可以概括为：将集合视为牌堆，不停的从牌堆中抽牌构成新的牌堆，直至新牌堆的牌数到达预设数量；underscore1.9版本开始，洗牌算法通过<code>_.sample</code>实现；
<code>_.sample(array,n)</code>:从array随机取出N个样本。 underscore中的抽样函数正基于洗牌算法。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">shuffle</span><span class="token punctuation">(</span><span class="token parameter">array</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> length <span class="token operator">=</span> array<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
    <span class="token comment">//拷贝一份原数组的副本。</span>
    <span class="token keyword">var</span> sample <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">var</span> index <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> length<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">var</span> temp <span class="token operator">=</span> sample<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span>
        sample<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> sample<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
        sample<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> sample<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="数组定位与摊平数组"><a href="#数组定位与摊平数组" class="header-anchor">#</a> 数组定位与摊平数组</h2> <ul><li>数组定位：<code>_.initial（array,n）</code>:获得array的除了最后N个元素以外的元素。   <code>.rest = .tail = .drop</code> :  <code>.rest(array,n)</code>返回array中除了前n个元素外的所有元素。</li> <li>摊平数组：<code>.flatten(array.shallow)</code>:摊平array，通过shallow指明是 深度摊平还是浅摊平。深度展开是就全部展开，浅度展开是只展开一层。</li></ul> <h2 id="去重函数-源码拾遗"><a href="#去重函数-源码拾遗" class="header-anchor">#</a> 去重函数&amp;源码拾遗</h2> <ul><li>_.unique 语法：<code>_.unique(array,isSorted,iteratee)</code>,根据iteratee设置的重复标准，对array进行去重，通过isSorted，提高对有序数组的去重效率。</li> <li>_.compact（array）:去除array中所有“假值”项目。在JavaScript中，这些值被认为是假值：false、null、0、&quot;&quot;、undefined、NaN；如何验证假值：Boolean（value）；</li> <li>_.range()函数作用：快速产生一个落在区间范围内的数组。<code>_.range(start,stop,step)</code>:设置步长step，产生一个[start,n]的序列.eg:</li></ul> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">// 产生[n,m]内的数组</span>
<span class="token function">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">11</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// =&gt; [1,2,3,4,5,6,7,8,9,10];</span>

<span class="token comment">// 指定步长</span>
<span class="token function">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">11</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token comment">// =&gt;[1,3,5,7,9];</span>

<span class="token comment">// 从[0,n)</span>
<span class="token function">range</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span>   <span class="token comment">//=&gt;[1,2,3,4];</span>
</code></pre></div><h2 id="patial偏函数-与-memoize缓存"><a href="#patial偏函数-与-memoize缓存" class="header-anchor">#</a> _.patial偏函数 与 _.memoize缓存</h2> <ul><li><em>.partial:偏函数（partial）反映了新函数是原函数的一部分，underscore的</em>.partial就能返回一个偏函数。</li> <li>_.partial(func,……args);应用一个函数，填充在任意个数的参数，不改变其动态this值，和bind方法很近。</li> <li>_.memoize （fucntion,[hashFunction]）：可以缓存某函数的计算结果，如果传递了hashFunction,就用hashFunction的返回值作为key存储函数的计算结果。hashFunction默认使用function的第一个参数作为key，memorize值得缓存可作为返回函数的cache属性。</li></ul> <h2 id="补充知识——正则课程"><a href="#补充知识——正则课程" class="header-anchor">#</a> 补充知识——正则课程</h2> <ul><li>正则表达式：语法：正则是描述一种字符串匹配的模式，可以用来检查一个串是否含有某种子串，将匹配的子串替换或者从某个串中取出符合某个条件的子串等。可以是单个字符、字符集合、字符范围。字符间的选择或者所有这些组件的任意组合。</li> <li>元字符、限定符、定位符（定位到行首或者行尾等）；</li> <li>创建正则对象：直接量语法，创建RegExp对象的语法。参数是一个字符串，指定正则表达式的模式或者其他正则表达式（g、i）；</li></ul> <h2 id="延迟执行函数、字符转义"><a href="#延迟执行函数、字符转义" class="header-anchor">#</a> 延迟执行函数、字符转义</h2> <ul><li>延迟执行delay :类似setTimeout ,等待wait毫秒后调用function，如果传递可选的参数arguments，当函数function执行时，arguments 会作为参数传入。</li></ul> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token function">_delay</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">,</span> wait <span class="token punctuation">,</span> <span class="token operator">*</span>arguments<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><ul><li>函数组合：任意函数的组合。compose，借助reduce方法顺序执行相应的函数;</li> <li>字符串转义escape，转义字符：也有更形象的译名：脱逸字符，逃逸字符。针对某些特定字符串转义并替换为特定字符串，_.escape(string)转义字符串，替换&amp;，&lt;,&gt;,&quot;,'和/字符；</li></ul> <h2 id="throttle与debounce-概念解析源码分析"><a href="#throttle与debounce-概念解析源码分析" class="header-anchor">#</a> throttle与debounce 概念解析源码分析</h2> <ul><li>throttle和debounce是解决请求和响应速度不匹配问题的两个方案，二者的差异在于选择不同的策略;</li> <li>debounce的关注点是空闲的间隔时间。</li> <li>throttle的关注点是连续的执行间隔时间。<br> <strong>应用场景</strong>：只要牵涉到连续事件或者频率控制相关的应用都可以考虑到这两个函数，比如：游戏射击、keydown事件、文本输入、自动完成、keyup事件。dom元素动态定位，window对象的resize和scroll事件 前两个debounce和throttle都可以按需使用，后两者肯定用throttle。</li></ul> <div class="custom-block tip"><p class="custom-block-title">TIP</p> <p><strong>节流</strong>：<code>_.throttle（function，wait，[options]）</code>  1.处理函数function是立即执行还是等待wait毫秒后执行？默认立即执行，如果options.leading == false 等待wait毫秒后调动执行。2、回调函数最后一次是否执行？默认会去执行，<code>options.trailing == false</code>，则不会去执行。<br> <strong>防抖</strong>：<code>_.debounce(function ,wait ,[immediate])</code>; immediate === false 等待wait毫秒后去调动处理函数。Immediate === true 立即执行处理函数。</p></div> <h2 id="属性操作-createassigner"><a href="#属性操作-createassigner" class="header-anchor">#</a> 属性操作&amp;createAssigner</h2> <p><strong>对象的属性操作</strong>：</p> <ul><li>检测是否有某个key属性：  has（obj，key） =&gt;true / false;</li> <li>获取obj对象上所有可枚举属性的名称  keys（obj） =&gt; [&quot;name&quot;]</li> <li>获取obj对象上所有可枚举的属性的值  values(obj) =&gt; [&quot;max];</li> <li>属性跟值进行替换，                 invert（obj） =&gt; {max : name}</li></ul> <div class="custom-block warning"><p class="custom-block-title">WARNING</p> <p>Object.keys() 在es5规范中存在，但是有兼容性问题，在IE9以下的版本有问题。且keys只能输出自身的属性，无法查找到原型链上的属性。
For in 可以找到自身属性以及可枚举的属性。但是在IE9以下：若将原型上的方法进行重构，会无法查询到扩展的方法。</p></div> <p>createAssigner underscore中提供了两个方法用于对象属性的扩展。<code>_.extend</code> ; <code>_.extendOwn</code>;这两个函数都是内部函数createAssigner进行创建的。createAssigner接受两个参数：keysFunc：获得对象属性的方式；defaults：声明是否要覆盖属性。返回一个属性分配器。</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/front-end-study/guide/" class="prev router-link-active">Jquery</a></span> <span class="next"><a href="/front-end-study/guide/module.html">module</a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/front-end-study/assets/js/app.8d50f10d.js" defer></script><script src="/front-end-study/assets/js/2.8d937a8c.js" defer></script><script src="/front-end-study/assets/js/20.79486553.js" defer></script>
  </body>
</html>
