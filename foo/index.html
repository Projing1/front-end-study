<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Vue专题 | 前端学习笔记</title>
    <meta name="description" content="前端学习中的一些笔记及总结">
    <meta name="theme-color" content="#3eaf7c">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
    
    <link rel="preload" href="/front-end-study/assets/css/0.styles.32c38af2.css" as="style"><link rel="preload" href="/front-end-study/assets/js/app.8d50f10d.js" as="script"><link rel="preload" href="/front-end-study/assets/js/2.8d937a8c.js" as="script"><link rel="preload" href="/front-end-study/assets/js/3.6cf61e10.js" as="script"><link rel="prefetch" href="/front-end-study/assets/js/10.f52eda7c.js"><link rel="prefetch" href="/front-end-study/assets/js/11.2a207987.js"><link rel="prefetch" href="/front-end-study/assets/js/12.01aa28b7.js"><link rel="prefetch" href="/front-end-study/assets/js/13.4527883c.js"><link rel="prefetch" href="/front-end-study/assets/js/14.c3b7450d.js"><link rel="prefetch" href="/front-end-study/assets/js/15.d4d389ff.js"><link rel="prefetch" href="/front-end-study/assets/js/16.a3638bd2.js"><link rel="prefetch" href="/front-end-study/assets/js/17.54f21fd6.js"><link rel="prefetch" href="/front-end-study/assets/js/18.3eb8d134.js"><link rel="prefetch" href="/front-end-study/assets/js/19.f7a3a423.js"><link rel="prefetch" href="/front-end-study/assets/js/20.79486553.js"><link rel="prefetch" href="/front-end-study/assets/js/21.978f0a17.js"><link rel="prefetch" href="/front-end-study/assets/js/22.6223d7e6.js"><link rel="prefetch" href="/front-end-study/assets/js/23.08148677.js"><link rel="prefetch" href="/front-end-study/assets/js/24.4b066b56.js"><link rel="prefetch" href="/front-end-study/assets/js/25.afa98a0a.js"><link rel="prefetch" href="/front-end-study/assets/js/26.1dd01e6e.js"><link rel="prefetch" href="/front-end-study/assets/js/27.87c9010a.js"><link rel="prefetch" href="/front-end-study/assets/js/4.b1577da0.js"><link rel="prefetch" href="/front-end-study/assets/js/5.bdaf13af.js"><link rel="prefetch" href="/front-end-study/assets/js/6.f4717c6c.js"><link rel="prefetch" href="/front-end-study/assets/js/7.996d1dce.js"><link rel="prefetch" href="/front-end-study/assets/js/8.203521e2.js"><link rel="prefetch" href="/front-end-study/assets/js/9.0a94c988.js">
    <link rel="stylesheet" href="/front-end-study/assets/css/0.styles.32c38af2.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/front-end-study/" class="home-link router-link-active"><!----> <span class="site-name">前端学习笔记</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/front-end-study/guide/" class="nav-link">高级前端开发课程</a></div><div class="nav-item"><a href="/front-end-study/config/" class="nav-link">实际项目中的错误汇总</a></div><div class="nav-item"><a href="https://www.vuepress.cn" target="_blank" rel="noopener noreferrer" class="nav-link external">
  VuePress
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/front-end-study/guide/" class="nav-link">高级前端开发课程</a></div><div class="nav-item"><a href="/front-end-study/config/" class="nav-link">实际项目中的错误汇总</a></div><div class="nav-item"><a href="https://www.vuepress.cn" target="_blank" rel="noopener noreferrer" class="nav-link external">
  VuePress
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>javascript进阶</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>单页应用专题</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/front-end-study/foo/" class="active sidebar-link">Vue专题</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/front-end-study/foo/#vue思想" class="sidebar-link">Vue思想</a></li><li class="sidebar-sub-header"><a href="/front-end-study/foo/#vue内部运行机制" class="sidebar-link">Vue内部运行机制</a></li><li class="sidebar-sub-header"><a href="/front-end-study/foo/#列表渲染和条件渲染" class="sidebar-link">列表渲染和条件渲染</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/front-end-study/foo/#条件渲染" class="sidebar-link">条件渲染</a></li><li class="sidebar-sub-header"><a href="/front-end-study/foo/#列表渲染" class="sidebar-link">列表渲染</a></li><li class="sidebar-sub-header"><a href="/front-end-study/foo/#显示过滤、排序的结果" class="sidebar-link">显示过滤、排序的结果</a></li><li class="sidebar-sub-header"><a href="/front-end-study/foo/#其他地方使用v-for" class="sidebar-link">其他地方使用v-for</a></li></ul></li><li class="sidebar-sub-header"><a href="/front-end-study/foo/#表单处理" class="sidebar-link">表单处理</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/front-end-study/foo/#基础用法" class="sidebar-link">基础用法</a></li><li class="sidebar-sub-header"><a href="/front-end-study/foo/#绑定值：" class="sidebar-link">绑定值：</a></li><li class="sidebar-sub-header"><a href="/front-end-study/foo/#修饰符" class="sidebar-link">修饰符</a></li></ul></li><li class="sidebar-sub-header"><a href="/front-end-study/foo/#组件" class="sidebar-link">组件</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/front-end-study/foo/#组件基础" class="sidebar-link">组件基础</a></li><li class="sidebar-sub-header"><a href="/front-end-study/foo/#组件间的数据传递" class="sidebar-link">组件间的数据传递</a></li><li class="sidebar-sub-header"><a href="/front-end-study/foo/#自定义事件" class="sidebar-link">自定义事件</a></li></ul></li><li class="sidebar-sub-header"><a href="/front-end-study/foo/#slot分发内容" class="sidebar-link">Slot分发内容</a></li><li class="sidebar-sub-header"><a href="/front-end-study/foo/#单文件和自定义组件" class="sidebar-link">单文件和自定义组件</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/front-end-study/foo/#单文件组件：" class="sidebar-link">单文件组件：</a></li><li class="sidebar-sub-header"><a href="/front-end-study/foo/#自定义组件简单写法" class="sidebar-link">自定义组件简单写法</a></li><li class="sidebar-sub-header"><a href="/front-end-study/foo/#动态组件和异步组件" class="sidebar-link">动态组件和异步组件</a></li></ul></li><li class="sidebar-sub-header"><a href="/front-end-study/foo/#渲染函数及jsx语法" class="sidebar-link">渲染函数及JSX语法</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/front-end-study/foo/#渲染函数" class="sidebar-link">渲染函数</a></li></ul></li><li class="sidebar-sub-header"><a href="/front-end-study/foo/#vue过渡与动画" class="sidebar-link">Vue过渡与动画</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/front-end-study/foo/#钩子函数" class="sidebar-link">钩子函数</a></li></ul></li><li class="sidebar-sub-header"><a href="/front-end-study/foo/#生命周期" class="sidebar-link">生命周期</a></li><li class="sidebar-sub-header"><a href="/front-end-study/foo/#自定义指令" class="sidebar-link">自定义指令</a></li><li class="sidebar-sub-header"><a href="/front-end-study/foo/#vue-cli初识" class="sidebar-link">vue cli初识</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/front-end-study/foo/#基于vue-cli快速构建——实战步骤" class="sidebar-link">基于vue-cli快速构建——实战步骤</a></li></ul></li><li class="sidebar-sub-header"><a href="/front-end-study/foo/#组件化深入" class="sidebar-link">组件化深入</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/front-end-study/foo/#组件化" class="sidebar-link">组件化</a></li><li class="sidebar-sub-header"><a href="/front-end-study/foo/#混入基本用法" class="sidebar-link">混入基本用法</a></li></ul></li><li class="sidebar-sub-header"><a href="/front-end-study/foo/#vuex的使用以及设计" class="sidebar-link">Vuex的使用以及设计</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/front-end-study/foo/#使用vuex" class="sidebar-link">使用vuex</a></li></ul></li><li class="sidebar-sub-header"><a href="/front-end-study/foo/#vue-router" class="sidebar-link">vue-router</a></li><li class="sidebar-sub-header"><a href="/front-end-study/foo/#vue组件通信" class="sidebar-link">Vue组件通信</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/front-end-study/foo/#组件通信" class="sidebar-link">组件通信</a></li></ul></li><li class="sidebar-sub-header"><a href="/front-end-study/foo/#自定义插件" class="sidebar-link">自定义插件</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/front-end-study/foo/#插件的作用及原理" class="sidebar-link">插件的作用及原理</a></li><li class="sidebar-sub-header"><a href="/front-end-study/foo/#自定义插件的封装" class="sidebar-link">自定义插件的封装</a></li></ul></li><li class="sidebar-sub-header"><a href="/front-end-study/foo/#单元测试" class="sidebar-link">单元测试</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/front-end-study/foo/#什么是单元测试" class="sidebar-link">什么是单元测试</a></li><li class="sidebar-sub-header"><a href="/front-end-study/foo/#如何进行单元测试" class="sidebar-link">如何进行单元测试</a></li></ul></li><li class="sidebar-sub-header"><a href="/front-end-study/foo/#vue编译器解析" class="sidebar-link">vue编译器解析</a></li></ul></li><li><a href="/front-end-study/foo/react.html" class="sidebar-link">react专题</a></li><li><a href="/front-end-study/foo/webpack.html" class="sidebar-link">webpack专题</a></li><li><a href="/front-end-study/foo/Vue-press.html" class="sidebar-link">Vue-press专题</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>H5移动端开发</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Node开发导学</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="vue专题"><a href="#vue专题" class="header-anchor">#</a> Vue专题</h1> <h2 id="vue思想"><a href="#vue思想" class="header-anchor">#</a> Vue思想</h2> <ul><li>数据驱动。<br> <strong>传统模式</strong>：1、用ajax从服务端获取数据，然后操作DOM来改变视图，  当前端交互要改变数据时，需要重复一次上述步骤，而手动操作DOM的过程很繁琐，且容易出错；<br> <strong>数据驱动-双向绑定</strong>：Vue采用MVVM设计模式，M—Model表示模型（javascript对象），V—View 是文档模型DOM（UI界面），ViewModel 表示一个Vue实例对象；</li> <li>组件化思想：<br> <strong>定义</strong>：组件可以扩展HTML元素，封装可重用代码；组件是自定义元素，Vue.js的编译器为它添加特殊功能，组件也可以扩展原生的HTML元素；<br> <strong>功能</strong>：组件能够把页面抽象成多个相对独立的模块，实现代码重用，提高开发效率和代码质量，使得代码易于维护。</li></ul> <h2 id="vue内部运行机制"><a href="#vue内部运行机制" class="header-anchor">#</a> Vue内部运行机制</h2> <ul><li>1）初始化 ：   new Vue() —init—&gt; $mount ; 在new Vue（）之后，Vue会调用_init函数进行初始化，初始化生命周期，事件、props、methods、data、computed与watch等、其中最重要的是通过<code>Object.defineProperty</code>设置setter与getter函数，用来实现响应式以及依赖收集。 初始化之后，调用$mount会挂载组件。</li> <li>2）编译：——&gt;compile()、 parse、optimize、generate、render function；编译三部曲：parse（解析）：利用正则将模板转换成抽象语法树（AST）； optimize（标记静态节点做优化）：标记静态节点，以后update的时候，diff算法可以跳过静态节点； generate（转成字符串）：将抽象语法树（AST）转成字符串，供render去渲染DOM。</li> <li>3）响应式：利用<code>Object.definePropety</code>设置data所返回对象，进行render function渲染时，读取data对象数据，触发getter函数，
对data中的属性进行依赖收集，放到观察者watcher 观察队列中；
修改data内属性会触发setter函数，通知观察者数据变化，观察者调用update更新视图。</li> <li>4）虚拟DOM：render function 会被转换成虚拟DOM——实际是一个JS对象，从顶层DOM层层描述DOM，有tag，children，isStatic（代表是否为静态节点），isComment（代表是否为注释节点）等等许多属性来做DOM描述。</li> <li>5）更新视图：数据变化后，执行render function可以得到一个新的VNode节点；得到新视图最简单粗暴的方法：直接解析新VNode节点，用innerHTML全部渲染到真实DOM中；update时，执行patch，传入新旧VNode，通过diff算法算出差异，局部更新视图，做到最优化。</li></ul> <h2 id="列表渲染和条件渲染"><a href="#列表渲染和条件渲染" class="header-anchor">#</a> 列表渲染和条件渲染</h2> <h3 id="条件渲染"><a href="#条件渲染" class="header-anchor">#</a> 条件渲染</h3> <p>v-if、v-else-if、v-else/v-show</p> <ul><li>v-if、v-else-if、v-else/v-show与JavaScript的条件语句if 、else、else if类似。vue的条件指令可以根据表达式的值，在dOM中渲染或销毁元素/组件。</li> <li>v-show不管初始条件是什么，元素总是会被渲染，并且只是简单地基于CSS进行显示隐藏切换。</li></ul> <table><thead><tr><th>v-if 使用场景</th> <th>v-show 使用场景</th></tr></thead> <tbody><tr><td>运行条件较少改变，展示带权限列表，可以在template上使用</td> <td>需要频繁切换（tab切换），展示前台页面数据，不可以在template上使用。</td></tr></tbody></table> <h3 id="列表渲染"><a href="#列表渲染" class="header-anchor">#</a> 列表渲染</h3> <p>v-for
当需要将一个数组遍历或枚举一个对象循环显示时，就会用到列表渲染指令v-for。 他的表达式需要结合 in 来使用，类似 item in items的形式。<br>
我们定义一个数组类型的数据items，用v-for将<code>&lt;li&gt;</code> 标签循环渲染，items是数据，item是当前数组元素的别名，循环出每个<code>&lt;li&gt;</code>内的元素都可以访问到对应的当前数据item，支持一个可选参数作为当前项的索引（index）。<br>
列表渲染也支持用of 来替代in作为分隔符。<br>
eg：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code>	<span class="token operator">&lt;</span>li v<span class="token operator">-</span><span class="token keyword">for</span><span class="token operator">=</span><span class="token string">&quot;{item , index} in items&quot;</span><span class="token operator">&gt;</span>
		item<span class="token punctuation">.</span>text
	<span class="token operator">&lt;</span><span class="token operator">/</span>li<span class="token operator">&gt;</span>
</code></pre></div><p>v-for 也可以渲染对象；不同的地方是：item对应的是key-value的 value值。  渲染对象的时候：有三个参数：item（对象的值），name（对象的key）；index(对象的索引)；</p> <div class="custom-block warning"><p class="custom-block-title">WARNING</p> <p>使用v-for需要提供一个维护状态，为了给vue一个提示，以便能跟踪每个节点的身份，从而重用和重新排序现有元素，你需要为每项提供一个唯一不可变更的Key属性。用于辨识vue的虚拟dom元素</p></div> <div class="language-javascript extra-class"><pre class="language-javascript"><code>	<span class="token operator">&lt;</span>li v<span class="token operator">-</span><span class="token keyword">for</span><span class="token operator">=</span><span class="token string">&quot;{item , index} in items&quot;</span> v<span class="token operator">-</span>bind<span class="token punctuation">:</span>key<span class="token operator">=</span><span class="token string">&quot;item.id&quot;</span><span class="token operator">&gt;</span>
		<span class="token punctuation">{</span><span class="token punctuation">{</span>item<span class="token punctuation">.</span>text<span class="token punctuation">}</span><span class="token punctuation">}</span>
	<span class="token operator">&lt;</span><span class="token operator">/</span>li<span class="token operator">&gt;</span>
</code></pre></div><h4 id="数组更新检测"><a href="#数组更新检测" class="header-anchor">#</a> 数组更新检测</h4> <ul><li>vue将被侦听的数组的变异方法进行了包裹，所以他们也将会触发视图更新，被包裹的方法有：push()/ pop()/shift()/unshift()/splice()/sort()/reverse();</li> <li>当使用非变异方法时，可以用新数组替换旧数组，涉及方法有filter（）、concat() 和 slice();</li> <li>两种情况不能监听： 当利用索引直接设置一个数组项时；当修改数组长度时。</li></ul> <h3 id="显示过滤、排序的结果"><a href="#显示过滤、排序的结果" class="header-anchor">#</a> 显示过滤、排序的结果</h3> <p>如果想要显示一个数组经过过滤或排序后的版本，而不实际改变或重置原始数据，可以创建一个计算属性，来返回过滤排序后的数组。</p> <h3 id="其他地方使用v-for"><a href="#其他地方使用v-for" class="header-anchor">#</a> 其他地方使用v-for</h3> <p>组件上以及template上可以使用v-for；</p> <div class="custom-block tip"><p class="custom-block-title">TIP</p> <p>注意事项：<br>
1、不推荐同时使用v-if和v-for 同时使用时，v-for具有比v-if更高的优先级；<br>
2、列表渲染给每项加key，vue处于效率考虑，会尽可能地复用已有的元素而非重新渲染，加上key有助于优化性能。在vue2.2以后 如果不加key 会报错。</p></div> <h2 id="表单处理"><a href="#表单处理" class="header-anchor">#</a> 表单处理</h2> <h3 id="基础用法"><a href="#基础用法" class="header-anchor">#</a> 基础用法</h3> <p>文本输入绑定：  v-model；</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token operator">&lt;</span>input v<span class="token operator">-</span>model<span class="token operator">=</span><span class="token string">&quot;message&quot;</span><span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>textarea v<span class="token operator">-</span>model<span class="token operator">=</span><span class="token string">&quot;message&quot;</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>textarea<span class="token operator">&gt;</span>
</code></pre></div><h3 id="绑定值："><a href="#绑定值：" class="header-anchor">#</a> 绑定值：</h3> <p>选择性框输入绑定值</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 单选按钮</span>
<span class="token operator">&lt;</span>input type<span class="token operator">=</span><span class="token string">&quot;radio&quot;</span> id<span class="token operator">=</span><span class="token string">&quot;one&quot;</span> v<span class="token operator">-</span>bind<span class="token punctuation">:</span>value<span class="token operator">=</span><span class="token string">&quot;value&quot;</span> v<span class="token operator">-</span>model<span class="token operator">=</span><span class="token string">&quot;pciked&quot;</span><span class="token operator">&gt;</span>

<span class="token comment">// 复选框</span>
<span class="token operator">&lt;</span>input type<span class="token operator">=</span><span class="token string">&quot;checkbox&quot;</span> id<span class="token operator">=</span><span class="token string">&quot;checkebox&quot;</span> v<span class="token operator">-</span>bind<span class="token punctuation">:</span><span class="token boolean">true</span><span class="token operator">-</span>value<span class="token operator">=</span><span class="token string">&quot;value1&quot;</span> v<span class="token operator">-</span>bind<span class="token punctuation">:</span>fasle<span class="token operator">-</span>value<span class="token operator">=</span><span class="token string">&quot;value2&quot;</span> v<span class="token operator">-</span>model<span class="token operator">=</span><span class="token string">&quot;checked&quot;</span> <span class="token operator">&gt;</span>

<span class="token comment">// 下拉选择：</span>
<span class="token operator">&lt;</span>select<span class="token operator">&gt;</span>
	<span class="token operator">&lt;</span>option disabled value<span class="token operator">=</span><span class="token string">&quot;&quot;</span><span class="token operator">&gt;</span>请选择<span class="token operator">&lt;</span><span class="token operator">/</span>option<span class="token operator">&gt;</span>
	<span class="token operator">&lt;</span>option v<span class="token operator">-</span>bind<span class="token punctuation">:</span>value<span class="token operator">=</span><span class="token string">&quot;{number:123}&quot;</span> <span class="token operator">&gt;</span><span class="token number">123</span><span class="token operator">&lt;</span>option<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>select<span class="token operator">&gt;</span>
</code></pre></div><h3 id="修饰符"><a href="#修饰符" class="header-anchor">#</a> 修饰符</h3> <ul><li>v-model.lazy :从input事件中转变为在change事件中同步数据；</li> <li>v-model.number :可以将输入转换为Number类型</li> <li>v-model.trim : 可以自动过滤输入时的首尾空格。</li></ul> <h2 id="组件"><a href="#组件" class="header-anchor">#</a> 组件</h2> <h3 id="组件基础"><a href="#组件基础" class="header-anchor">#</a> 组件基础</h3> <p>为什么要使用组件：组件（component）是对数据和方法的简单封装，vue组件可以扩展HTML元素，提高重用性，让代码可复用。
组件的使用：</p> <ul><li>组件命名：两种方式：1）使用kebab-case（短横线分隔命名）<code>&lt;my-component&gt;</code> 2）使用PascalCase（首字母大写命名）</li> <li>组件复用： 可以将组件进行任意次复用，每个组件都会独立维护它的实例数据。</li> <li>组件注册： 两种方式：1）全局注册。2）局部注册。</li></ul> <h3 id="组件间的数据传递"><a href="#组件间的数据传递" class="header-anchor">#</a> 组件间的数据传递</h3> <p>使用prop向子组件传递数据</p> <ul><li>prop书写规则： 使用DOM中的模板时，驼峰命名的prop名需要使用其等价的短横线分割命名；</li> <li>prop基本用法： 传递静态或动态的prop</li> <li>传递特性： 所有的prop都使得其父子prop之间形成了一个单向下行绑定（单向数据流）；</li></ul> <p>可以使用prop传递动态值给到子组件，直接在子组件的props的数组中增加名称。eg:</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code>	<span class="token operator">&lt;</span>my<span class="token operator">-</span>component v<span class="token operator">-</span>bind<span class="token punctuation">:</span>message<span class="token operator">=</span><span class="token string">&quot;message&quot;</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>my<span class="token operator">-</span>component<span class="token operator">&gt;</span>
	<span class="token comment">// 在data里定义出message。</span>
</code></pre></div><p>组件prop的数据验证：当组件需要提供别人使用时，推荐都进行数据验证；<br>
验证的type类型可以是：String、Number、Boolean、Object、Array、Function、Symbol、Date，type也可以是一个自定义构造器，使用instanceof检测。<br>
做数据验证以对象的形式写props，键为参数名，值为需要的验证方式。<br>
当prop验证失败时，在开发版本下会在控制台抛出一条警告。</p> <h3 id="自定义事件"><a href="#自定义事件" class="header-anchor">#</a> 自定义事件</h3> <ul><li>使用场景： 当子组件需要向父组件传递数据时，就要用到自定义事件。</li> <li>基本用法： 当子组件用$emit()来触发事件，父组件用$on()来监听子组件的事件。</li> <li>自定义组件的v-model ：一个组件上的v-model默认会利用名为value的prop和名为input的事件。</li> <li>将原生事件绑定到组件： 使用v-on的.native修饰符监听原生事件。</li> <li>.sync修饰符：父组件监听自定义事件按需更新数据。
eg:自定义事件：实现一个具有双向绑定的v-model组件，要满足下面两个要求：</li> <li>1、接收一个value属性；</li> <li>2、在有新的value时触发input事件。</li></ul> <h2 id="slot分发内容"><a href="#slot分发内容" class="header-anchor">#</a> Slot分发内容</h2> <p>什么是Slot：</p> <ul><li>插槽（Slot） ： Vue提出来一个概念，插槽用于决定将所携带的内容，插入到指定的某个位置，从而使模板分块，具有模块化的特质和更大的重用性。</li> <li>当需要让组件组合使用，混合父组件的内容与子组件的模板时，就会用到Slot。
插销分类：</li> <li>单个插槽： 在子组件内使用特殊<code>&lt;Slot&gt;</code>元素，就可以为这个子组件开启一个slot（插槽）；在父组件模板里，插入在子组件标签内的所有内容将替代子组件的<code>&lt;slot&gt;</code>标签及它的内容。</li> <li>具名插槽： 给<code>&lt;slot&gt;</code>元素指定一个name后（在父组件中使用slot属性取名。在子组件中使用name命名），可以分发多个内容，具名slot可以与单个slot共存。</li> <li>作用域插槽： 是一种特殊的slot 使用一个可以复用的模板替换已渲染元素。</li></ul> <h2 id="单文件和自定义组件"><a href="#单文件和自定义组件" class="header-anchor">#</a> 单文件和自定义组件</h2> <ul><li>单文件组件： 一个后缀名为.vue的文件，使用.vue文件需要先安装vue-loader 、vue-style-loader等加载器，并做webpack配置。因为要使用ES6语法，还需要安装配置babel和babel-loader等编译器。</li> <li>自定义组件： 类似element-UI这类组件库，都是为了完成一些自定义或者特定业务的，这一类组件都可以称之为自定义组件。</li></ul> <h3 id="单文件组件："><a href="#单文件组件：" class="header-anchor">#</a> 单文件组件：</h3> <p>每个.vue 文件包含三种类型的顶级语言块————<code>&lt;template&gt; 、&lt;script&gt; 、&lt;style&gt;</code>还允许添加可选的自定义块。</p> <h3 id="自定义组件简单写法"><a href="#自定义组件简单写法" class="header-anchor">#</a> 自定义组件简单写法</h3> <p>创建一个文件夹，里面创建myComponent.vue和myComponent.js文件，在vue项目中入口文件main.js中或者需要使用的文件中，进行导入，使用vue.use();</p> <h3 id="动态组件和异步组件"><a href="#动态组件和异步组件" class="header-anchor">#</a> 动态组件和异步组件</h3> <ul><li>动态组件：vue.js提供了一个特殊元素<code>&lt;component&gt;</code>用来动态挂载不同的组件，使用is特性来选择要挂载的组件，这样的组件叫动态组件，另外可以使用<code>&lt;keep-alive&gt;</code>标签来使组件进行缓存。</li> <li>异步组件： Vue.js允许将组件定义为一个工厂函数，动态的解析组件，Vue组件需要渲染时触发工厂函数，并且把结果缓存起来，用于后面的再次渲染，我们把这类组件称之为异步组件。</li></ul> <h2 id="渲染函数及jsx语法"><a href="#渲染函数及jsx语法" class="header-anchor">#</a> 渲染函数及JSX语法</h2> <h3 id="渲染函数"><a href="#渲染函数" class="header-anchor">#</a> 渲染函数</h3> <p>渲染函数（render函数）</p> <ul><li>通过createElement函数来创建虚拟DOM（VirtualDom），这个虚拟DOM包含的信息会告诉Vue页面上需要渲染出什么元素。</li> <li>可以解决有些场景中用template实现起来代码冗长繁琐，而且大量重复的问题。
渲染函数解析：</li> <li>render函数的返回值： VNode(即：虚拟节点)，也就是我们要渲染的节点。</li> <li>render函数的参数 ： createElement是render函数的参数，它本身也是个函数，并且有三个参数，createElement函数的返回值也是VNode虚拟节点。第一个参数必选，可以是一个HTML标签，也可以是一个组件或函数；第二个是可选参数，数据对象，在template中使用，第三个是子节点，也是可选参数，用法一致。
节点、树及虚拟DOM<br>
概念：当浏览器读到一些DOm结构时，会建立一个“DOM节点”树来保持追踪所有内容，如同你会画一张家谱树来追踪家庭成员的发展一样，<br>
虚拟DOM（VirtualDom）就是通过一种VNode（节点）类表达的，每个DOM元素或组件都对应一个VNode对象。<br>
使用JavaScript对象模拟了Dom结构的树形结构，这个树结构包含整个DOM结构的信息。
<img src="/front-end-study/assets/img/virtualDom.03014fb0.jpg" alt="虚拟DOM运行原理"></li></ul> <h4 id="jsx语法及函数式组件"><a href="#jsx语法及函数式组件" class="header-anchor">#</a> JSX语法及函数式组件</h4> <p>JSX语法：是JavaScript和XML结合的一种格式，最早是react发明了JSX，利用HTML语法来创建虚拟DOM。JSX执行更快，因为它再编译为Javascript代码后进行了优化。类型是安全的，在编译过程中就能发现错误，使用JSX编写模板更加简单快捷。  JSX语法需要babel插件转译为普通的HTML。</p> <h4 id="函数式组件"><a href="#函数式组件" class="header-anchor">#</a> 函数式组件</h4> <p>可以把函数式组件想象成组件里的一个函数，入参是渲染上下文（render context），返回值是渲染好的HTML，特性：1.Stateless（无状态）：组件自身是没有状态的。2、instanceless（无实例）：组件自身没有实例，也就是没有this。参数是靠context来传递的，context完整属性可参照官方文档查询。<br>
context对象：<br>
props：提供所有prop的对象；<br>
children：VNode子节点的数组；<br>
slots：一个函数，返回了包含所有插槽的对象。<br>
scopedSlots：一个暴露传入的作用域插槽的对象，也以函数形式暴露普通插槽，<br>
data：传递给组件的整个数据对象，作为createElement的第二个参数传入组件<br>
parent ：对父组件的引用；<br>
listeners ： 一个包含所有父组件为当前组件注册的时间监听器的对象，这是data.on的一个别名。
injections：如果使用了inject选项，则该对象包含了应当被注入的属性。</p> <h2 id="vue过渡与动画"><a href="#vue过渡与动画" class="header-anchor">#</a> Vue过渡与动画</h2> <p>Vue在插入、更新或者移除DOM时，提供多种不同方式的应用过渡效果。也提供了内置的过渡封装组件，该组件用于包裹要实现过渡效果的组件。
<img src="/front-end-study/assets/img/transition.3bf1e6e5.jpg" alt="过渡"><br>
过渡时会有6个类名在enter/leave的过渡中切换  ：</p> <p><img src="/front-end-study/assets/img/transitionclass.42b62dd9.jpg" alt="过渡类的切换">;</p> <h3 id="钩子函数"><a href="#钩子函数" class="header-anchor">#</a> 钩子函数</h3> <p>钩子函数可以结合CSS 的transitions /animations使用，也可以单独使用。<br>
当只使用JavaScript过渡时，在enter和leave中必须使用done进行回调，否则，他们将被同步调用，过渡会立即完成。<br>
初始渲染的过渡：可以通过appear特性设置节点在初始渲染的过渡。无论是appear特性还是v-on：appear钩子都会生成初始渲染过渡。<br>
多个元素过渡：当有相同标签名的元素切换时，需要通过key特性设置唯一的值来标记以让vue区分它们，否则Vue为了效率只会替换相同标签内部的内容，即使在技术上没有必要，给在<code>&lt;transition&gt;</code>组件中的多个元素设置key是一个更好的实践。<br>
多个组件的过渡：我们不需要key特性，我们只需要使用动态组件。<br>
列表过渡：同时渲染整个列表，在这种场景中，使用<code>&lt;transition-group&gt;</code>组件。<br>
可复用的过渡：过渡可以通过vue的组件系统实现复用。要创建一个可复用过渡组件，你需要做的是将<code>&lt;transition&gt;</code> 或者 <code>transition-group</code>作为根组件。然后将任何组件放置在其中就可以了。<br>
动态过渡：在Vue中即使是过渡也是数据驱动的，动态过渡最基本的例子是通过name特性来绑定动态值。所有过渡特性都可以动态绑定，还可以通过事件钩子获取上下文中的所有数据。<br>
状态过度： 对于数据元素本身的动效，这些数据要么本身就以数值形式存储，要么可以转换为数值，有了这些数值后，我们就可以结合Vue的响应式和组件系统，使用第三方库来实现切换元素的过渡状态。</p> <h2 id="生命周期"><a href="#生命周期" class="header-anchor">#</a> 生命周期</h2> <p>生命周期钩子函数（Hook）在Vue中是一种事件劫持机制， 它会比定义的事件更早进行执行处理，而且可以让你自己去配置。<br> <em><strong>beforeCreate</strong></em> ：实例创建前状态，el与data都为undefined<br> <em><strong>created</strong></em> ：创建完毕状态，el为undefined，data里面已经有数据；数据请求一般写在这个里面。<br> <em><strong>beforeMount</strong></em> ： 挂载前转态。el为undefined，data里面已经有数据；<br> <em><strong>mounted</strong></em> ：挂载后状态，el与data都有相应的属性，第三方库一般在这个里面写。<br> <em><strong>beforeUpdate</strong></em> ： 更新前状态，data里面的属性值改变，el:[object HTMLDivElement]<br> <em><strong>updated</strong></em> : 更新完成状态，data里面的属性值改变，el:[object HTMLDivElement]<br> <em><strong>beforeDestory</strong></em> ： 销毁前状态；<br> <em><strong>destoryed</strong></em> ： 销毁状态。</p> <h2 id="自定义指令"><a href="#自定义指令" class="header-anchor">#</a> 自定义指令</h2> <p>为什么要使用自定义指令。<br>
在vue2中，代码复用和抽象的主要形式是组件，然而，有的情况下，我们仍然需要对普通DOM元素进行底层操作，这时候就会用到自定义指令。除了内置指令（v-if等）外，vue.js也允许注册自定义指令。<br>
自定义指令提供一种机制将数据的变化映射为DOM行为。<br>
可以用Vue。directive（id，definition）方法注册一个全局自定义指令，它接收两个参数指令ID与定义对象，也可以用组件的directive选项注册一个局部自定义指令。<br>
自定义指令钩子函数：定义对象可以提供几个钩子函数：<br>
bind： 只调用一次，在指令第一次绑定到元素上时调用。
update： 在bind之后立即以初始值为参数第一次调用，之后每当绑定值变化时调用，参数为新值与旧值。<br>
upbind： 只调用一次，在指令从元素上解绑时调用。<br>
动态指令参数：可以是动态的，例如，在v-mydirective:[argumenmt]= &quot;value&quot;中，argument参数可以根据组件实例数据进行更新！这使得自定义指令可以在应用中被灵活使用。</p> <h2 id="vue-cli初识"><a href="#vue-cli初识" class="header-anchor">#</a> vue cli初识</h2> <p>Vue-cli是vue的脚手架，是一个基于vue进行快速开发的完整系统，用于自动生成vue.js+webpack的项目模板，分为两种：</p> <ul><li><code>vue init webpack-simple项目名</code></li> <li><code>vue init webpack 项目名</code><br>
Vue-cli 可以快速构建单页应用，但涉及内容很多，如webpack、npm、node.js等。<br> <em><strong>vue-cli系统包含的组件</strong></em>：<br>
cli是一个全局安装的npm 包，提供了终端的vue命令。<br>
cli服务，它是一个npm包，局部安装在每个@vue/cli 创建的项目中。<br>
cli插件 向你的vue项目提供可选功能的npm包，例如Babel/TypeScript转译、ESLint集成、单元测试和end-to-end测试等。</li></ul> <h3 id="基于vue-cli快速构建——实战步骤"><a href="#基于vue-cli快速构建——实战步骤" class="header-anchor">#</a> 基于vue-cli快速构建——实战步骤</h3> <p>安装node.js —— 下载服务器框架 —— 实现一个静态服务器。<br>
cli2生成的目录：</p> <ul><li>build ：里面是一些操作文件，使用npm run * 时其实执行的就是这里的文件；</li> <li>config 配置文件，执行文件需要的配置信息；</li> <li>src 资源文件，所有组件以及资源、页面入口文件等；</li> <li>static 静态文件目录；</li> <li>test ：测试文件目录；</li> <li>index.html 入口文件； .babelrc : babel的配置文件，按照一定要求解析ES6的代码。  .editorconfig : 配置编辑器的相关内容，   .eslintrc.js配置eslint检测的内容。  package.json :项目描述文件，项目结构，需要什么依赖等。</li></ul> <p>webpack：前端资源模块化管理和打包工具</p> <ul><li>可以将很多松散的模块，按依赖和规则打包成符合生产环境部署的前端资源；</li> <li>可以将按需加载的模块进行代码分割，等实际需要的时候再异步加载。
要自动实现上述功能，需要提前编辑好配置文件。</li></ul> <div class="custom-block tip"><p class="custom-block-title">TIP</p> <p>vue-cli脚手架工具用配置好的模板迅速搭建项目工程，省去自己配置webpack配置文件的基本内容。</p></div> <p>vue-cli生成项目的步骤：<br>
安装vue-cli ： npm install @vue/cli -g ;</p> <h2 id="组件化深入"><a href="#组件化深入" class="header-anchor">#</a> 组件化深入</h2> <h3 id="组件化"><a href="#组件化" class="header-anchor">#</a> 组件化</h3> <p>组件是vue.js最强大的功能之一；</p> <ul><li>可以扩展HTML元素，封装可重用的代码；</li> <li>在较高层面上是自定义元素，Vue.js的编译器为它添加特殊功能。</li> <li>在有些情况下也可以是原生HTML元素形式，以is特性扩展。<br>
组件创建：
1、调用Vue.extend(),创建名为myComp的组件，template定义模板的标签，模板内容需要写在该标签下。</li></ul> <div class="language-vue extra-class"><pre class="language-vue"><code>var myComp = Vue.extend({
	template:'<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span>这是我的组件<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>'
})
</code></pre></div><p>2、template标签创建，需要加上id属性；</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token operator">&lt;</span>template id<span class="token operator">=</span><span class="token string">&quot;myComp&quot;</span><span class="token operator">&gt;</span>
	<span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>这是templat构建的组件<span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>template<span class="token operator">&gt;</span>
</code></pre></div><p>3、script标签创建，需要加id属性，同时还要加type=&quot;text/x-template&quot; 不执行编译里面的代码；</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token operator">&lt;</span>script type<span class="token operator">=</span><span class="token string">&quot;text/x-template&quot;</span> id<span class="token operator">=</span><span class="token string">&quot;myComp&quot;</span><span class="token operator">&gt;</span>
	<span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>这是script标签创建的组件。<span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span>
</code></pre></div><h4 id="组件注册"><a href="#组件注册" class="header-anchor">#</a> 组件注册</h4> <p>1、调用Vue.extend()创建名为myComp的组件，再进行全局注册。</p> <div class="language-js extra-class"><pre class="language-js"><code>Vue<span class="token punctuation">.</span><span class="token function">component</span><span class="token punctuation">(</span><span class="token string">'my-comp'</span><span class="token punctuation">,</span>myComp<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>2、template及script标签构建的组件全局注册。</p> <div class="language-js extra-class"><pre class="language-js"><code>Vue<span class="token punctuation">.</span><span class="token function">component</span><span class="token punctuation">(</span><span class="token string">'my-comp'</span><span class="token punctuation">,</span><span class="token punctuation">{</span>
	template<span class="token punctuation">:</span> <span class="token string">'#myComp'</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>处理边界情况。<br>
1、访问根实例：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">//获取根组件的数据 获取到data里面的数据。</span>
<span class="token keyword">this</span><span class="token punctuation">.</span>$root<span class="token punctuation">.</span>foo 

<span class="token comment">// 写入根组件的数据。</span>
<span class="token keyword">this</span><span class="token punctuation">.</span>$root<span class="token punctuation">.</span>foo <span class="token operator">=</span> <span class="token number">2</span> <span class="token punctuation">;</span>
</code></pre></div><p>2、访问父级组件：</p> <div class="language-js extra-class"><pre class="language-js"><code>	<span class="token keyword">this</span><span class="token punctuation">.</span>$parrnt<span class="token punctuation">.</span><span class="token constant">XXX</span><span class="token punctuation">;</span> 
</code></pre></div><p>3、访问子组件实例或子元素：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">//通过ref特性为这个子组件赋予一个ID引用</span>
<span class="token operator">&lt;</span>base<span class="token operator">-</span>input ref<span class="token operator">=</span> <span class="token string">&quot;usernameInput&quot;</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>base<span class="token operator">-</span>inpt<span class="token operator">&gt;</span>

<span class="token comment">// 访问usernameInput子组件</span>
<span class="token keyword">this</span><span class="token punctuation">.</span>$refs<span class="token punctuation">.</span>usernameInput
</code></pre></div><p>4、依赖注入</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function-variable function">provide</span><span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token keyword">return</span> <span class="token punctuation">{</span>
		getMap <span class="token punctuation">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>getMap
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
inject <span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'getMap'</span><span class="token punctuation">]</span>
</code></pre></div><p>5、程序化的时间侦听器：
使用程序化的事件侦听器让多个输入框元素同时使用不同的Pikaday，每个新的实例都程序化地在后期清理它自己。</p> <h3 id="混入基本用法"><a href="#混入基本用法" class="header-anchor">#</a> 混入基本用法</h3> <p>混入提供了一种非常灵活的方式，来分发Vue组件中的可复用功能，一个混入对象可以包含任意组件选项，当组件使用混入对象时，所有混入对象的选项将被“混合”进入该组件本身的选项。<br>
mixin全局混入：<br>
混入也可以进行全局注册，使用时格外小心，一旦使用全局混入，它将影响每个之后创建的Vue实例，使用恰当时，这可以用来为自定义选项注入处理逻辑。</p> <h2 id="vuex的使用以及设计"><a href="#vuex的使用以及设计" class="header-anchor">#</a> Vuex的使用以及设计</h2> <p>vuex是一个专门为Vue.js应用程序开发的状态管理模式。<br>
它采用集中式存储管理应用的所有组件的状态，并以相应的规则，保证状态以一种可预测的方式发生变化。</p> <ul><li>vuex默认的五种基本对象：</li> <li>state: 存储状态（变量）；</li> <li>getters： 对数据获取之前的再次编译，可以理解为state的计算属性；</li> <li>mutations ：修改状态，并且是同步的，在组件中使用$store.commit('',params)。这个和我们组件中使用的自定义事件类似。</li> <li>actions ： 异步操作，在组件中使用是$store.dispatch('');</li> <li>module : store的子模块，为了开发大型项目，方便状态管理而使用的。</li></ul> <h3 id="使用vuex"><a href="#使用vuex" class="header-anchor">#</a> 使用vuex</h3> <p>1、安装Vuex <code>npm install vuex --save</code><br>
2 引用vuex</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">import</span> Vue <span class="token keyword">from</span> <span class="token string">'vue'</span> 
<span class="token keyword">import</span> Vuex <span class="token keyword">from</span> <span class="token string">'vuex'</span>
Vue<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span>Vuex<span class="token punctuation">)</span>   <span class="token comment">//要用use使用一下。 </span>
</code></pre></div><p>3、创建仓库store</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 创建一个store </span>
<span class="token keyword">const</span> store <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vuex<span class="token punctuation">.</span>Store</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>store 对象包含四个子对象：</p> <ul><li>state ：用于存储数据，类似vue实例的data属性。</li> <li>mutations ：唯一修改state的方法，修改过程是同步的。</li> <li>actions：发出事件，事件监听程序一般会调用mutations对state进行修改，action事件本身是异步的，提交的是mutation，而不是直接变更状态。</li> <li>getter：用于对state的数据进行筛选，过滤。</li></ul> <p>vuex的设计思想：<br>
vuex 使用单一状态树，用一个对象State包含了整个应用层级的所有状态，你可以理解为这些状态就是一堆全局变量和数据。<br>
简而言之 Vuex采用类似全局对象的形式来管理所有组件的公用数据，如果想修改这个全局对象的数据，得按照Vuex提供的方式来修改（不能随意用自己的方式来修改）；</p> <h2 id="vue-router"><a href="#vue-router" class="header-anchor">#</a> vue-router</h2> <p>什么是路由：</p> <h2 id="vue组件通信"><a href="#vue组件通信" class="header-anchor">#</a> Vue组件通信</h2> <h3 id="组件通信"><a href="#组件通信" class="header-anchor">#</a> 组件通信</h3> <p>什么是组件通信：实际上指各个组件间，进行参数或者信息的相互传递，每个组件都是一个独立功能的整体，当我们要将这些组件拼接在一起时，就需要在这些组件之间建立通信。<br>
组件通信的几种类型：</p> <ul><li>父子组件通信：1、使用props和$emit父子组件相互通信，2、父组件$children操作子组件。 3、子组件$parent访问父组件。</li> <li>非父子组件通信： 1、使用中央事件总线（eventbus）来处理非父子组件间的通信，2、祖先元素通过provide提供数据，后代通过inject获取该数据。3、使用$attrs和$listeners实现祖孙组件通信。4、$root直接访问根组件。</li></ul> <h2 id="自定义插件"><a href="#自定义插件" class="header-anchor">#</a> 自定义插件</h2> <h3 id="插件的作用及原理"><a href="#插件的作用及原理" class="header-anchor">#</a> 插件的作用及原理</h3> <ul><li>代码复用，功能扩展；</li> <li>Vue提供了插件机制，可以在全局添加一些功能，它们可以简单到几个方法，属性，也可以很复杂，比如一整套组件库，如elementUI。</li></ul> <h3 id="自定义插件的封装"><a href="#自定义插件的封装" class="header-anchor">#</a> 自定义插件的封装</h3> <p>插件用法：Vue.use(MyPlugin) 本质上是调用MyPlugin.install(Vue);<br>
使用插件必须在new Vue() 启动应用之前完成，实例化之前就要配置好，<br>
如果使用Vue.use多次注册相同插件，那只会注册成功一次。</p> <h4 id="数据校验插件需求"><a href="#数据校验插件需求" class="header-anchor">#</a> 数据校验插件需求</h4> <p>需求内容：1、处理自定义rules规则，2、这个rules需要一个对象；3、该对象指定组件中的数据的验证规则。</p> <h2 id="单元测试"><a href="#单元测试" class="header-anchor">#</a> 单元测试</h2> <h3 id="什么是单元测试"><a href="#什么是单元测试" class="header-anchor">#</a> 什么是单元测试</h3> <ul><li>针对程序的最小单元来进行正确性检验的测试工作</li> <li>通俗的讲是为了测试某一个类或某一个方法能都正常工作，而写的测试代码。<br>
单元测试作用： 减少bug，提高代码质量，快速定位bug，减少调试时间，放心重构。</li></ul> <h3 id="如何进行单元测试"><a href="#如何进行单元测试" class="header-anchor">#</a> 如何进行单元测试</h3> <p>TDD： 测试驱动开发<br>
BDD： 行为驱动开发<br>
单元测试常用工具：<br>
Mocha 一个JavaScript测试框架，就是运行测试的工具；<br>
Chai 一个Mocha可以使用的断言库，判断源码的实际执行结果与预期结果一致。<br>
Vue Test Utils 是Vue.js官方的单元测试实用工具库<br>
supertest 代理HTTP请求。</p> <h2 id="vue编译器解析"><a href="#vue编译器解析" class="header-anchor">#</a> vue编译器解析</h2> <p>template ---&gt; parse(解析出类型，tag标签，子节点等各种内容，) ---&gt;  optimize(标注静态节点) ----&gt;  generate(解析节点然后交给渲染函数render，生成VNode) ---&gt; _updata(render())(两个分支：分支1，首次渲染initial render 映射成真正的DOM， 分支2：数据更新，新旧VNode的对比，以及diff算法，)</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/front-end-study/guide/module.html" class="prev">module</a></span> <span class="next"><a href="/front-end-study/foo/react.html">react专题</a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/front-end-study/assets/js/app.8d50f10d.js" defer></script><script src="/front-end-study/assets/js/2.8d937a8c.js" defer></script><script src="/front-end-study/assets/js/3.6cf61e10.js" defer></script>
  </body>
</html>
