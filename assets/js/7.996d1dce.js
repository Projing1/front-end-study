(window.webpackJsonp=window.webpackJsonp||[]).push([[7],{203:function(t,s,e){t.exports=e.p+"assets/img/daolun.01f106ff.png"},216:function(t,s,e){"use strict";e.r(s);var r=e(0),a=Object(r.a)({},(function(){var t=this,s=t.$createElement,r=t._self._c||s;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h1",{attrs:{id:"模块化编程"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#模块化编程"}},[t._v("#")]),t._v(" 模块化编程")]),t._v(" "),r("h2",{attrs:{id:"模块系统概述"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#模块系统概述"}},[t._v("#")]),t._v(" 模块系统概述")]),t._v(" "),r("h3",{attrs:{id:"模块化定义-优势"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#模块化定义-优势"}},[t._v("#")]),t._v(" 模块化定义/优势")]),t._v(" "),r("p",[t._v("模块化就是把系统分离成独立功能的方法，这样我们需要什么功能，就加载什么功能。"),r("br"),t._v("\n当一个项目开发得越来越复杂时，会遇到一些问题：1、命名冲突，2、文件依赖。使用模块化开发，可以避免以上问题，并且提高开发效率,并且代码可维护行，可复用性较好。在生产角度，模块化开发室一种生产方式，这种方式生产效率高，维护成本低。")]),t._v(" "),r("h3",{attrs:{id:"commonjs"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#commonjs"}},[t._v("#")]),t._v(" commonJS")]),t._v(" "),r("p",[t._v("commonjs规范加载模块是同步的，也就是说，加载完成才执行后面的操作，node.js主要用于服务器编程，模块都是存在本地硬盘中加载比较快，所以node.js采用commonjs规范。"),r("br"),t._v("\ncommonJs规范分为三部分：")]),t._v(" "),r("ul",[r("li",[t._v("moudule（模块标识）：module变量在每个模块内部，就代表当前模块；")]),t._v(" "),r("li",[t._v("require（模块引用）：exports属性书对外的接口，用于导出当前模块的方法或变量；")]),t._v(" "),r("li",[t._v("exports（模块定义）require用来加载外部模块，读取并执行js文件，返回该模块的exports对象。")])]),t._v(" "),r("h3",{attrs:{id:"amd（requirejs）"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#amd（requirejs）"}},[t._v("#")]),t._v(" AMD（requirejs）")]),t._v(" "),r("p",[t._v("AMD规范（requirejs）AMD是异步模块定义，它采用异步方式加载模块，通过define方法定义模块，require方法加载模块，"),r("br"),t._v(" "),r("strong",[t._v("AMD模块的定义")]),t._v("：如果这个模块还需要依赖其他模块，那么define函数的第一个参数，必须是一个数组，指明该模块的依赖，"),r("br"),t._v(" "),r("strong",[t._v("AMD的加载")]),t._v("：require（['modules',callback]）;第一个参数是一个数组，里面的成员就是要加载的模块。第二个参数callback，则是加载成功后的回调函数，require（）异步加载math，浏览器不会失去响应，它指定的回调函数，只有前面的模块都加载成功后，才会运行，解决了依赖性的问题。")]),t._v(" "),r("h3",{attrs:{id:"cmd（seajs）"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#cmd（seajs）"}},[t._v("#")]),t._v(" CMD（seajs）")]),t._v(" "),r("p",[t._v("CMD即通用模块定义，CMD规范是国内发展出来的，正如AMD有requirejs，CMD有个浏览器的实现Seajs；Seajs要解决的问题和requirejs一样，只不过在模块定义方式和模块加载方式上有所不同。 在CMD规范中，一个模块就是一个文件，代码的书写格式如下：define（function（require，exports，module）{//模块代码}）； require是可以把其他模块导入进来的一个参数exports可以把模块内的一些属性和方法导出，module是一个对象，上面存储了与当前模块相关联的一些属性和方法，\nCMD推崇依赖就近，延迟执行，文件是提前加载好，只有在require的时候才会去执行文件。")]),t._v(" "),r("h3",{attrs:{id:"es6模块化"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#es6模块化"}},[t._v("#")]),t._v(" ES6模块化")]),t._v(" "),r("p",[t._v("ES6模块化：在ES6之前没有模块化，为了解决问题，提出了commonJS，AMD，CMD；ES6模块化汲取了commonJS和AMD的优点，语法简洁，支持异步加载，未来可以成为浏览器和服务器通用的模块化解决方案。ES6新增了两个关键字："),r("strong",[t._v("export和import")]),t._v("。")]),t._v(" "),r("ul",[r("li",[t._v("export用于把模块里的内容暴露出来，import用于引入模块提供的功能。")]),t._v(" "),r("li",[t._v("import加载模块：")])]),t._v(" "),r("div",{staticClass:"language-javascript extra-class"},[r("pre",{pre:!0,attrs:{class:"language-javascript"}},[r("code",[r("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("import")]),t._v(" "),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("bar"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("foo"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("test"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("obj"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" "),r("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("from")]),t._v("  "),r("span",{pre:!0,attrs:{class:"token string"}},[t._v("'./lib'")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),r("span",{pre:!0,attrs:{class:"token function"}},[t._v("foo")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),r("div",{staticClass:"custom-block tip"},[r("p",{staticClass:"custom-block-title"},[t._v("TIP")]),t._v(" "),r("p",[t._v("注：可以使用Export default命令，为模块制定默认输出，一个模块只能有一个默认输出，所以export default只能使用一次。")])]),t._v(" "),r("p",[r("strong",[t._v("ES6模块运行机制")]),t._v("：ES6模块是动态引用，如果使用import从一个模块加载变量（即： import foo from ‘foo’），变量不会被缓存，而是成为一个指向被加载模块的引用，等脚本执行时，根据只读引用，到被加载的那个模块中取值。"),r("br"),t._v(" "),r("strong",[t._v("模块的定义")]),t._v("：")]),t._v(" "),r("ul",[r("li",[t._v("约定：所有JavaScript文件都应该用模块的形式来书写，并且一个文件只包含一个模块；")]),t._v(" "),r("li",[t._v("使用全局函数define来定义模块"),r("code",[t._v("define（factory[require,exports，module])")]),t._v("；exports用来向外提供模块的API||使用return直接向外提供API。require函数用来访问其他模块提供的API。module参数存储模块的元信息，（id模块的唯一标识deps依赖列表exports对外提供额接口对象。")]),t._v(" "),r("li",[t._v("factory函数在调用时，会始终传入三个参数：require。exports和module，这三个参数在左右模块代码里可用。模块加载器会从"),r("code",[t._v("factory.toString()")]),t._v("中解析出当前模块所依赖的模块，它是一个有模块标识组成的数组。")])]),t._v(" "),r("div",{staticClass:"custom-block tip"},[r("p",{staticClass:"custom-block-title"},[t._v("TIP")]),t._v(" "),r("p",[t._v("所以：1、在模块代码中，第一个参数必须命名为require，2、不要重命名require函数，或在任何作用域中给require重新赋值，3、require的参数值必须是字符串直接量，不能是表达式。")])]),t._v(" "),r("h2",{attrs:{id:"加载器结构设计导论"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#加载器结构设计导论"}},[t._v("#")]),t._v(" 加载器结构设计导论")]),t._v(" "),r("p",[r("img",{attrs:{src:e(203),alt:"加载器结构设计"}})]),t._v(" "),r("h3",{attrs:{id:"模块部分"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#模块部分"}},[t._v("#")]),t._v(" 模块部分")]),t._v(" "),r("p",[t._v("每个模块创建都先初始化数据，存储在缓存对象中。"),r("br"),t._v("\n数据初始化：加载器中设计了一个名为module的构造函数，每个模块都是次构造函数的实例对象。构造函数中给实例对象扩展了“未来”所需要用到的属性和方法。"),r("br"),t._v("\n模块存储：加载器中设计了一个名为cache缓存对象，每个文件（模块）都会存储在cache对象中。具体存储方式：{“当前模块绝对路径”：new Module()}")]),t._v(" "),r("div",{staticClass:"custom-block warning"},[r("p",{staticClass:"custom-block-title"},[t._v("WARNING")]),t._v(" "),r("p",[t._v("注意：当前模块的绝对路径是通过资源部分，资源定位方法实现的。")])]),t._v(" "),r("h3",{attrs:{id:"资源部分"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#资源部分"}},[t._v("#")]),t._v(" 资源部分")]),t._v(" "),r("p",[t._v("资源定位依赖管理是加载器设计两大核心。"),r("br"),t._v("\n资源定位：加载器中设计了一个resolve（）方法把模块名解析成绝对路径格式，模块名的获取：")]),t._v(" "),r("ul",[r("li",[t._v('startUp.use(["a.js","b.js"]);'),r("br"),t._v(" "),r("code",[t._v("startUp.use()")]),t._v("加载器启动方法，启动时会去调用传入数组列表中的模块。")]),t._v(" "),r("li",[t._v('动态加载script文件：通过加载器resolve（）方法把模块名解析成绝对路径格式。动态创建script ：document.creat("script");src指向当前模块绝对路径地址，加载文件同时，模块加载器解析当前模块所依赖的模块以数组的形式存储。'),r("br"),t._v('\n依赖管理：已知当前模块在cache中的形态，{"当前模块绝对路径"：new Module（）} 换算：1、{“当前模块绝对路径”：{uri:"当前模块绝对路径"，deps：[]}} ； deps存储当前模块的依赖列表。依赖列表通过动态加载script文件正则解析获取。')])]),t._v(" "),r("div",{staticClass:"custom-block warning"},[r("p",{staticClass:"custom-block-title"},[t._v("WARNING")]),t._v(" "),r("p",[t._v("重点：解析依赖——>获取依赖模块绝对路劲地址——>动态加载——>提取依赖——>解析依赖。递归方式加载所有模块，直至模块全部加载完毕。")])]),t._v(" "),r("h2",{attrs:{id:"module构造器设计——模块数据初始化"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#module构造器设计——模块数据初始化"}},[t._v("#")]),t._v(" module构造器设计——模块数据初始化")]),t._v(" "),r("p",[t._v("依赖加载策略，基于树形结构的加载策略。"),r("br"),t._v("\n模块数据初始化：模块初始化——module构造函数——数据初始化：")]),t._v(" "),r("ul",[r("li",[t._v("实例方法：load分析主干（子树）上的依赖项resolve资源定位；")]),t._v(" "),r("li",[t._v("实例属性：")]),t._v(" "),r("li",[r("ul",[r("li",[t._v("this.uri = uri;当前模块的绝对路径地址;")])])]),t._v(" "),r("li",[r("ul",[r("li",[t._v("this.deps =deps || [];当前模块依赖列表;")])])]),t._v(" "),r("li",[r("ul",[r("li",[t._v("this.exports = null;当前对外暴露接口对象；")])])]),t._v(" "),r("li",[r("ul",[r("li",[t._v("this.status = 0;当前模块状态；")])])]),t._v(" "),r("li",[r("ul",[r("li",[t._v("This.waitings = {};有多少个依赖项；")])])]),t._v(" "),r("li",[r("ul",[r("li",[t._v("this.remain = 0; 还有多少个未加载的依赖项。"),r("br"),t._v("\n模块的生命周期：status = 1 正在当前模块获取uri ;"),r("br"),t._v("\nstatus = 2 缓存中存储模块数据信息 ；"),r("br"),t._v("\nstatus = 3 正在加载当前模块依赖项，"),r("br"),t._v("\nstatus = 4 朱本执行当前模块；"),r("br"),t._v("\nstatus = 5 正在执行当前模块；status = 6 执行完毕接口以获取。")])])])]),t._v(" "),r("h2",{attrs:{id:"deepclone深度克隆-pick"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#deepclone深度克隆-pick"}},[t._v("#")]),t._v(" deepclone深度克隆&pick")]),t._v(" "),r("ul",[r("li",[r("code",[t._v("_.clone(object)")]),t._v(":克隆一个对象的副本。"),r("code",[t._v("_deepClone(object)")]),t._v(":深度克隆一个对象。两者的区别在于克隆后的对象与原对象是否全等。")]),t._v(" "),r("li",[t._v("深度克隆：重新全部复制一个与要复制的对象一样的对象。但是与原对象不是同一个。")]),t._v(" "),r("li",[r("code",[t._v("_.pick(object,keys)")]),t._v("返回一个object副本，只过滤出keys(有效的键组成的数组)参数指定的属性值，或者接受一个判断函数，指定挑选哪个key。")])])])}),[],!1,null,null,null);s.default=a.exports}}]);